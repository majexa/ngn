#Ngn
> __Ngn__ (ɛnʤn) — PHP/JS fullstack-фреймворк.<br>MVC, database wrappers, cli, scafolding, migrations etc.

[Красивая версия этой доки](http://doc.majexa.ru/doc/ngn)


##Базовые константы
Базовая конфигурация проекта должна иметь 3 константы.

1. project/site/config/constants/core.php:
  - `PROJECT_KEY`<br>
    Это уникальный идентификатор проекта. Он не должен содержать ничего, кроме латинских букв в любом регистре. Позднее Вы узнаете в каких случаях он будет использоваться.
2. project/site/config/constants/more.php:
  - `SITE_DOMAIN`<br>
    Домен сайта, например `site.com`
3. project/site/config/constants/site.php:
  - `SITE_TITLE`<br>
    Название сайта

^Для включения _Режима отладки_ добавьте в файл `core.php` константу `IS_DEBUG = true`. Это позволит видеть все ошибки, а так же работать с системными командами, вроде очистки кэша, через адресную строку.

##Собственная инициализация
Для расширения стандартной инициализации проекта, осуществляемой фреймворком, всегда можно добавить свой функционал. Просто создайте файл `project/site/init.php` и наполните его всем необходимым. 

<a name="di"></a>

^Таким функционалом может стать внедрение зависимых инъекций.<br>
Далее пример инъекций одного из проектов:

    O::replaceInjection('DefaultRouter', 'KpRouter');
    O::replaceInjection('RouterScripts', 'KpRouterScripts');
    O::registerInjection('DdFieldsFields', 'DdFieldsFieldsOrder', ['orders']);
    O::registerInjection('DdFieldsManager', 'DdFieldsManagerOrder', ['orders']);
    O::registerInjection('DdFields', 'DdFieldsSubclient', ['subclients']);
    O::registerInjection('DdXls', 'DdXlsOrders', ['orders'], false);
    O::registerInjection('OrderSend', 'KpOrderSend');
    O::registerInjection('SubclientsFinder', 'KpSubclientsFinder');

##Очистка кэша
При включенном `IS_DEBUG` кэш приложения очищается из адресной строки параметром `?cc=1`.

Из консоли командой `php cmd.php cc`.

##Контроллеры

- Контроллер — это класс, наследуемый от `CtrlBase` и начинающийся с `Ctrl`
- Экшн — это ф-я контроллера начинающаяся с `action_`
- Какой экшн вызывать определяет строка URL. Она разбирается на части по символу `/` в массив
- Какой из элементов массива считать именем экшена, определает ф-я контроллера `CtrlBase::getParamActionN()`. Если возвращает `0`, значит по запросу `http://site.com/param1/param2` будет вызван `action_param1()`
- По запросу `http://site.com/` будет вызыван экшн по-умолчанию `action_default()`, `action_json_default()` или `action_ajax_default()`. Последние 2 описываются в главе «Экшены асинхронных запросов». 
- Экшн формирует массив для шаблона: `$this->d`
- Какой шаблон будет выведен в данном экшене определяет внутренняя логика контроллера

###Экшены асинхронных запросов
Встроенный функционал базового контроллера поддерживает специализированые экшены для асинхронных запросов.
Это экшены, начинающиеся с префиксов `action_ajax_` и `action_json_`.

Примеры:

    class CtrlSnippet extends CtrlBase {
      // Не правильный пример:
      function action_ajax_html() {
        print '<b>Some snippet text</b>';
      }
      // Правильный пример:
      // Используйте свойство CtrlBase::$ajaxOutput, что бы вывод текста
      // осуществлялся фреймворком в одном месте в простых проектах это
      // может быть не важно. Но если Вам вдруг потребуется пост-обработка
      // текста во всех асинхронных запросах, красивее будет сделать это имея
      // одну точку вывода.
      function action_ajax_html() {
        $this->ajaxOutput = '<b>Some snippet text</b>';
      }
      // В json-экшене заполняются элементы массива CtrlBase::$json
      function action_json_html() {
        $this->json['snippet'] = '<b>Some snippet text</b>';
      }
    }

^json-экшены имеют также встроенную поддержку _SFLM-подгрузчика_. Если при выполнении такого экшена в _SFLM-фронтенд_ будут
 добавлены новые пути, отдаваемый клиенту json-массив пополниться технической инфорамцией для предварительной подгрузки
 этих путей. Подробнее в главе SFLM.

##Роутинг

До вызова контроллера, его необходимо определить. Эта процедура называется роутинг. Роутинг осуществляется роутером. В Ngn существует несколько видов роутеров. Сейчас мы рассмотрим тот, что обрабатывает запросы к фронтенду сайта, т.е. к его публичным страницам. Класс `DefaultRouter`. Метод `DefaultRouter::_getController()` возвращает объект контроллера. Разберём по какому принципе происходит определение класса контроллера.

###Контроллеры по умолчанию

Если константа `PROJECT_KEY = three`, а `SITE_DEOMIN = site.com`, то поиск классов Контроллеров будет происходить в такой последовательности.
Первый найденный и будет использоваться.

- для запроса `http://site.com/`:
  - CtrlThreeDefault
  - CtrlDefault

- для запроса `http://sub.site.com/`:
  - CtrlThreeSub
  - CtrlThreeDefault
  - CtrlDefault

- для запроса `http://sub.site.com/some`:
  - CtrlThreeSome
  - CtrlSome
  - CtrlThreeSub
  - CtrlThreeDefault
  - CtrlDefault

Если вы используете [свой роутер](#Изменение_стандартного_поведения_роутера),  в нём реализован
метод `prefix`:
  
    protected function prefix() {
      return 'CtrlSomething';
    }
  
- для запроса `http://site.com/` в этом случае порядок поиска будет таким:
   
  - CtrlThreeDefault
  - CtrlSomethingDefault
  - CtrlDefault

^Узнать какой контроллер используется в данный момент можно добавив в запрос GET параметр `showController=1` (при условие что _Режим отладки_ включен)

###Изменение стандартного поведения роутера

Описанное выше поведение можно легко дополнить или полностью изменить, если оно не удовлетворяет ваши нуждам. Ngn имеет под капотом мощный инструмент для переопределения классов на основе паттерна [Dependency Injection](#di). Классы, поддерживающие переопределение можно найти в коде Ngn по ключевому слову `O::di`. Класс `DefaultRouter` из их числа. Само переопределение реализуется методом `O::replaceInjection()`. Это безусловное переопределение. Про условное будет сказано в другой главе. Рассмотрим результат на примере:

Создаём файл собственной инициализации `project/site/init.php`

    O::replaceInjection('DefaultRouter', 'MyRouter');

* Здесь и далее в примерах опускаются открывающие php-тэги `<?php`. Это сделано для удобства чтения. Учитывайте это при копировании. 

Создаём файл класса роутера `project/site/lib/MyRouter.class.php`

    class MyRouter extends DefaultRouter {
      protected function prefix() {
        return 'CtrlSpecial';
      }
    }

^ Все классы должны находится в папке `project/site/lib` (или её подпапках).

^ Учтите, список всех классов в php-автозагрузчике кэшируется. Так что после добавления нового класса, кэш нужно очистить. Из адресной строки это делается запросом с параметром `?cc=1`.


В роутере был переопределен метод `prefix()`, который в стандартной реализации возвращал строку `Ctrl`. Для такого роутера последовательность поиска контроллеров будет следующей:

- для запроса `http://sub.site.com/some`:
  - CtrlThreeSome
  - CtrlSpecial
  - CtrlThreeSub
  - CtrlThreeDefault
  - CtrlSpecialDefault
  - CtrlDefault

Переопределяя метод `DefaultRouter::_getController()` и используя объект `Req` можно внедрять любую логику определения контроллеров в зависимости от запроса.

##Объект запроса
__класс `Req`__

Объект запроса предоставляет разобранные данные из строки URL.
Этот объект присутствует как в роутерах, так и контроллерах (`$this->req`).
В первую очередь это уже знакомый нам массив параметров Req::$params. Параметрами запроса называются строки, разделённые слэшем.

Так же <i>Объект запроса</i> выполняет ряд простых, но полезных в работе с роутерами функций:

- __Проверка входных параметров__. В случае, если проверка не прошла выбрасывается исключение
{apiPhp Req}

- __Обёртка для $_GET, $_POST, $_REQUEST__.
  Эти массивы представленны в Объекте запроса соответствующими свойствами: Req::$g, Req::$p, Req::$r. Предпочтительно использовать именно их. Да. Ничего страшного не произойдёт, если вы напишете где-нибудь в контроллере `if (isset($_GET['email'])) ...`. Но есть пара причин, когда это сможет Вам повешать в дальшейшем:
  - Использование сложной логики в контроллерах может потребовать вызывать один из другого. В таком случае дочерний контроллер должен быть создан со своим уникальным _Объектом запроса_.
  - Тестирование вашего приложения так же может потребовать создавать контроллеры с необходимым для тестирования запросом не нарушая принципов изолированности объекта.
 
##Шаблоны
- Шаблоны представляют собой php-файлы вида
  `<html><?= $d['somevar'] ?></html>`, где `$d` — это свойство контроллера `CtrlBase::$d`
- Данные для шаблонов создаются либо в контроллере, либо передаются родительским шаблоном.
- Что бы наглядно увидеть где на сайте используется какой шаблон, определите константу `TEMPLATE_DEBUG = true` в файле `site/config/constants/more.php`
- В HTML-коде сайта появятся подобные комментарии: `<!-- Begin Template "/home/user/ngn-env/sb/tpl/main" -->`
- В PHP-коде путь к такому шаблону будет выглядеть так: `main`.
  В результате будет производится поиск файла шаблона по следующим путям в файловой системе:
  - `/home/user/ngn-env/projects/projectName/site/tpl/main.php`
  - `/home/user/ngn-env/sb/tpl/main.php`
  - `/home/user/ngn-env/ngn/tpl/main.php`

В соответствующем порядке. Так что для переопределения шаблона `/home/user/ngn-env/sb/tpl/main` нужно создать в своём проекте соответствующий файл `/home/user/ngn-env/projects/projectName/site/tpl/main.php`

###Главный шаблон `main`
_Главный шаблон_ — это шаблон лейаута страницы. Он может выглядеть примерно так:

    <html>
      <head><?= $d['tpl'] ?></head>
      <body><?= $this->tpl($d['tpl'], $d) ?></body>
    </html>

Имя _Главного шаблона_ находится в переменной `$d['mainTpl']` и имеет значение `main`

###Примеры использования шаблонов в связке с контроллером

    class CtrlThreeDefault extends CtrlBase {
      function action_default() {
        $this->d['someVar'] = 123;
      }
    }

Содержимое `project/site/tpl/main.php`:

    <html>
      <body><?= $this->tpl($d['tpl'], $d) ?></body>
    </html>

Содержимое `project/site/tpl/default.php`:

    <b>someVar:</b> <?= $d['someVar'] ?>

Результат рендеринга шаблона:

    <html>
      <body><b>someVar:</b> 123</body>
    </html>

Имя _Внутреннего шаблона_ находится в переменной `$d['tpl']` и имеет значение `default`, если оно не определено в контроллере.

##Форма
_Форма_  — это объект класса `Form` или его наследника.
В Ngn _Формы_ выполняют следующие роли:

- генерация HTML-форм
- конвертация данных из формата HTML-формы в формат полей источника данных
- фильтрация пользовательских данных на основе типов полей

HTML-шаблоны вывода полей формы можно переопределить в свойстве `Form::$templates`.

^ В Ngn принято использовать стандартные HTML-шаблоны вывода полей формы, т.к. на них основан client-side слой фреймворка. Например, client-side валидация.

###Элемент поля формы
__Элемент поля формы__ — это объект класса вида `FieldE{Type}`, наследуемый от `FieldEAbstract`, где `Type` — тип поля.
_Элементы полей формы_ создаются внутри _Формы_, а их опции задаются в её конструкторе.

[todo тут должно быть API конструктора]

Вот основные задачи, которые выполняет _Элемент поля формы_:

- вывода HTML-кода поля
- инициализации JS-кода поля;
- инициализации CSS-кода поля;
- преобразования данных из формата источника в формат поля;
- преобразования данных из формата поля в формат источника;
- серверной валидации данных из поля.

`FieldEAbstract` — базовый класс, от которого наследуются классы всех _Элементов полей_.
{apiPhp FieldEAbstract}

Пример валидации:

    class FieldEName extends FieldEText {
    
      protected function validate2() {
        if (!Misc::validName($this->options['value'])) {
          $this->error('Неправильный формат');
        }
      }
    }

`FieldEInput` используется для всех полей ввода пользовательских данных, таких как `input`, `select`, `textarea` и др.

Список опций, общих для любого _Элемента поля_-предка `FieldEInput`:

- `name`: имя поля; атрибут `name` HTML-тега
- `id`: атрибут `id` HTML-тега. Если не указан, генерируется из имени: `Misc::name2id($name)`
- `required`: обязательно ли для заполнения
- `title`: название поля
- `help`: описание/подсказка под полем
- `cssClass`: css-класс для HTML-тега (`input`/`select`/`textarea`)
- `value`: значение поля. Заполняется автоматически _Формой_
- `maxlength`: максимальная длина для текстовых полей
- `disabled`, `placeholder`, `autocomplete`, `multiple`: соответствуют аналогичным HTML-атрибутам
- `data`: этот массив будет трансформирован в `data-key="value"` атрибуты HTML-тега
- `jsOptions`: опции для JS-класса этого элемента

###Валидация в классе _Формы_
Валидировать данные на серверной стороне на уровне _Формы_ нужно в методе Form::_initErrors()
Ошибки можно создавать для полей формы или для всей формы целиком, если ошибку сложно отнести к какому-то конкретному полю:

    class FormA extends Form {
      protected function _initErrors() {
        // Ошибка отобразится рядом с полем
        $el = $this->getElement('name');
        if ($el['value'] != 'correct') {
          $el->error('Введите в поле "Имя" слово "correct"');
        }
        // Ошибка отобразится в начале формы
        if ($this->getElement('name')['value']  != 'correct') {
          $this->globalError('Введите в поле "Имя" слово "correct"');
        }
      }
    }
    
####CSS элемента поля
При создании _элемента поля_ для него добавляется CSS файл.
Он ищется в `Sflm::absBasePaths` путях.
вместе с ним был добавлен [sflm-фронтенд](/doc/sflm#sflm-фронтенд)
тут: css/formEl/{Type}.css


###Формы в шаблонах

В шаблоне, как было сказано выше, используется готовый HTML сгенерированой формы.
Рендeринг _Формы_ чаще всего удобней делать в контроллере.
Там же мы будем обрабатывать данные из _Формы_.

Возьмём контроллер, рассмотренный выше, и измним его для работы с _Формой_. Шаблоны при этом остаются такими же.

    class CtrlThreeDefault extends CtrlBase {
      function action_default() {
        $form = new Form([
          [
            'title' => 'Название',
            'type' => 'text',
            'name' => 'title',
            'required' => true
          ]
        ]);
        if ($form->isSubmittedAndValid()) {
          // Произошел сабмит формы. Валидация так же прошла успешно.
          // Дописываем дамп массива в файл с идентификатором формы.
          file_put_contents(
            DATA_PATH.'/'.$form->id(),
            var_dump($form->getData(), true),
            FILE_APPEND
          );
          $this->d['someVar'] = 'Ваши данные успешно сохранены';
        } else {
          // Если не было сабмита или проблемы с валидацией, рендерим
          // форму и помещаем HTML-код в переменную, которая выводится
          // во Внутреннем шаблоне
          $this->d['someVar'] = $form->html();
        }
      }
    }

###API Формы
{apiPhp Form}

###Диалоговые формы
Диалоговые формы - это HTML-формы, созданные серверным классом `Form`, загруженные ajax-json-заросом,
инициализированые клиент-сайд классом Ngn.Form через класс диалога `Ngn.Dialog.RequestForm`.

Встроенный функционал базового контроллера `CtrlBase` позволяет выполнять специальные запросы
для генерации _Диалоговых Форм_. Рассмотрим виды таких запросов.

Все взаимодействия клиент-сайд диалогом и сервером происходят через json. Для того что бы контроллер
сам добавил нужные данные из _Формы_ в json, необходимо просто возвратить в экшене _Форму_.
Посмотрите на примере:

    class FormA extends Form {
      function __construct() {
        parent::__construct([
          [
            'title' => 'Имя',
            'name' => 'name'
          ]
        ], [
          'title' => 'Заголовок диалога'
          'submitTitle' => 'OK'
        ]);
      }
      protected function _initErrors() {
        // Если в поле введено другое слово, при сабмите диалог не закроется,
        // а отобразится та же форма с ошибкой валидации
        if ($this->getElement('name')['value']  != 'correct') {
          $this->globalError('Введите в поле "Имя" слово "correct"');
        }
      }
      protected function _update(array $data) {
        // Если при сабмите валидация пройдена, вызовется этот метод,
        // а AJAX-JSON запрос вернёт FALSE и диалог успешно закроется
        file_put_contents('some/file', var_dump($data, true);
      }
    }
    
    class CtrlA {
      function action_json_a() {
        return FormA;
      }
    }

Такой структуры достаточно, что бы обеспечить 3 различные типа поведений:

 1. __При первом запросе на отображение формы__. Откроется диалог и в нём загрузится форма
 2. __При сабмите и проваленой валидации__. Диалог останется открытым, а в форму добавятся ошибки 
 3. __При сабмите и успешной валидации__. Диалог закроется после того, как на сервере выполнится метод `Form::_update()`
 
^ Опция "title" в конструкторе _Формы_ используется только для заголовка диалога. Если мы будем
выводить форму стандартным методом `Form::html()`, этот заголовок нигде не отобразится.

###Последовательное отображение нескольких Формовых диалогов

При успешном сабмите _Формового диалога_ и дальнейшем её закрытии можно открыть следующее диалоговое окно.
Такое может быть полезно при составлении "визардов" на основе механизма _Диалоговых форм_. Для этого
достаточно добавить в JSON параметр `nextFormUrl`. Если _Диалог_ был закрыт со статусом `OK` (т.е. не по
кнопке "X" или "Отмена"), то после закрытия откроется новый _Формовый диалог_ по ссылке `nextFormUrl`. 


##Авторизация
Авторизация пользователей происходит в базовом класса роутера `Router`.

Таким образом для любого запроса, проходящего через роутеры, устанавливается сессия авторизации.

{apiPhp Auth}

Пример авторизации через GET запрос:

    http://site.com/some/path?authLogin=user&auhPass=password
    
###Выход

Пример для любого запроса, проходящего через роутеры:

    http://site.com/some/path?logout=1
    
После выхода генерирует JS код для редиректа на ту же страницу.

###Выход без редиректа

Пример для любого запроса, проходящего через роутеры:

    http://site.com/some/path?clear=1
    
##Регистрация
Имеет настройки конфигурации
^^/god/configManager/vvv/userReg



##Менеджер данных
_Менеджер данных_ является связующим звеном между Формой и источником данных.
Он предоставляет абстрактный интерфейс для создания CRUD операций.
Так же _Менеджер данных_ является ядром для действий, специфичных для различных типов полей.
Т.е. CRUD-операции выполняются не только на утровне источника данных (например БД), но так же и на
уровне каждого поля. Например, для поля вставки файла, такими операциями будут создание и удаление файла.

В Ngn существует несколько типов _Менеджеров данных_. Все они - предки класса `DataManagerAbstract`.
Рассмотрим базовый функционал _Менеджера данных_, находящийся в этом классе:
{apiPhp DataManagerAbstract}

Как видно из описания метода `DataManagerAbstract::requestUpdate()` существует несколько возможностей для расширения поведения
при сохранении данных, например `DataManagerAbstract::beforeUpdate()`. Как на уровне _Менеджера данных_, так и на уровне _Экшенов полей_.

Сделаем пример реализации собственного _Менеджера данных_:

    class FileDataManager extends DataManagerAbstract {
      function getItem($id) {
        require DATA_PATH."/$id";
      }
      protected function _create() {
        $id = getLastFileIndex(DATA_PATH) + 1; // индекс новой записи
        file_put_contents(
          DATA_PATH."/$id",
          // $this->data — данные из Формы
          "<?php\n\n".var_dump($this->data, true).';'
        );
        return $id;
      }
      protected function _update() {
        file_put_contents(
          DATA_PATH."/".$this->id, // $this->id — ID редактируемой записи
          "<?php\n\n".var_dump($this->data, true).';'
        );
      }
      protected function _delete() {
        unlink(DATA_PATH."/".$this->id);
      }
    }

Теперь посмотрим как использовать его в роутере. Сделаем форму добавления новой записи:

    class CtrlThreeDefault extends CtrlBase {
      function action_default() {
        $manager = new FileDataManager;
        if ($manager->requestCreate()) {
          $this->d['someVar'] = 'Ваши данные успешно сохранены';
        } else {
          $this->d['someVar'] = $manager->form->html();
        }
      }
    }

Добавим экшн для редактирования уже существующих записей:

    function action_edit() {
      $manager = new FileDataManager;
      if ($manager->requestUpdate($this->req['id'])) {
        $this->d['someVar'] = 'Ваши данные успешно сохранены';
      } else {
        $this->d['someVar'] =
          '<h1>Редактирование записи '.$manager->defaultData['title'].'</h1>'.
            $manager->form->html();
      }
    }

В последнем листинге к HTML-коду формы, добавляется так же заголовок редактируемой записи `$manager->defaultData['title']`.
Массив данных текущей записи доступен благодаря выполнению `requestUpdate()`.

Заголовок, полученный из _Формы_, можно вывести так: `$manager->data['title']`.

^ Обращаться к параметрам запроса можно напрямую: `$this->req['id']`.
Такая запись (благодаря `ArrayAccesseble`) аналогична этой: `$this->req->r['id']`.

###Экшены полей
_Экшены полей_ дают возможность создавать поля вместе с изолироваными обработчиками данных.
Такой подход позволяет не только использовать существующий
функционал многократно в любых _Менеджерах данных_, но и комбинировать любое количество типов полей, с готовым
проверенным поведением.

_Экшены поля_ — это методы класс вида `Dmfa{Type}`, наследуемый от `Dmfa`, где `Type` - тип поля.
Экшены бывают 2-х типой. Посмотрите на их заголовки:

    /**
     * Data Manager Field Action
     * look at DataManagerAbstract::getDmfa()
     */
    abstract class Dmfa {
     
      /**
       * @var DataManagerAbstract
       */
      protected $dm;
    
      function __construct(DataManagerAbstract $dm) {
        $this->dm = $dm;
      }
    
      // function form2sourceFormat($v) { return $v; }
      // function source2formFormat($v) { return $v; }
      // function elBeforeCreateUpdate(FieldEAbstract $el) {}
      // function elAfterCreateUpdate(FieldEAbstract $el) {}
      // function elAfterUpdate(FieldEAbstract $el) {}
      // function elBeforeDelete(FieldEAbstract $el) {}
    
    }

Первые 2 выполняются, когда _Элемент поля формы_ ещё не создан. В метод передаётся значение поля, полученное из _Формы_.

Другие 4 получают в качестве аргумента _Элемент поля формы_. Значение этого поля доступно по укороченной записи `$el['value']`.

Придумаем несколько экшнов для поля с типом `phone`:

    class DmfaPhone extends Dmfa {
      // в БД числовое поле; вырезаем плюс
      function form2sourceFormat($v) {
        return ltrim($v, '+');
      }
      // а в форме всё будет как надо с плюсом
      function source2formFormat($v) {
        return '+'.$v;
      }
      // добавляем в Менеджер данных ещё одно значение для сохранения
      function elBeforeCreateUpdate(FieldEAbstract $el) {
        $this->dm->data['secondaryPhone'] = $el['value'];
      }
      protected function resourceFile(FieldEAbstract $el) {
        // ---------------------->  в значении поля всё ещё есть "+", вырезаем
        return DATA_PATH.'/'.$el['name'].'_'.ltrim($el['value'], '+');
      }
      // создаём ресурс (файл)
      function elAfterCreateUpdate(FieldEAbstract $el) {
        file_put_contents($this->resourceFile($el));
      }
      // записываем в лог, например
      function elAfterUpdate(FieldEAbstract $el) {
        log('phone changed: '.$el['value']);
      }
      // удаляем ресурс
      function elBeforeDelete(FieldEAbstract $el) {
        unlink($this->resourceFile($el));
      }
    }

##Панель управления
Для каждого веб-проекта, работающего под управлением Ngn, доступна _Панель управления_.
В пустом проекте будут доступны всего несколько разделов: _Логи_, _Конфигурация_ и _Структуры_.

__Логи__ - это веб-отображения логов сайта. Сюда сваливаются сообщения оставленные через метод `LogWriter::v('logName', 'message')`. Их можно найти в папке `project/site/logs`. Файлы с префиксом `r_`.

__Конфигурация__ - это веб-отображение конфигурации проекта. Значения по умолчанию можно найти в папках `ngn/more/config/vars`, `ngn/more/config/constants`. Описание структуры переменных и констант в папке `ngn/more/config/struct`.

__Структуры__ - веб-интерфейс для создания dd-структур.

Ссылки в главное меню _Панели управления_ добавляются через конфиг `project/site/config/vars/adminTopLinks.php`.

    <?php

    return [
      [
        'link'  => Tt()->getPath(1).'/ddItemsFilter/orders',
        'class' => 'list',
        'title' => 'Заявки',
      ]
    ];


##Отключения БД в _Стандартных проектах_
 
   print (new DefaultRouter(['disableSession' => true]))->dispatch()->getOutput();
   
В корне проекта должен находится файл `keepIndex`, что бы утилита `pm` не заменила
корневой `index.php` на стандартный.

##Работа с БД

Для работы с базой данных Ngn предоставляет:

- 2 низкоуровневых инструмента:
  - объект создания плоских запросов `Db`. Базируется на библиотеке [DbSimple](http://dklab.ru/lib/DbSimple/)
  - объект условий `DbCond`
- 2 реализации объектно-реляционного проецирования:
  - модели `DbModelCore`
  - библиотека `Dynamic Data`

Рассмотрим каждый отдельно.

###1. Выполнение SQL-запросов

Основной задачей класса Db является прозрачная защита от SQL-инъекций при составлением запросов с помощью плейсхолдеров.

Экземпляр этого класса с настройками подключения к локальной базе проекта всегда доступен через глобальную функцию `db()`.

{apiPhp Db}

Пример запроса с плейсхолдерами:

    db()->query('SELECT * FROM users WHERE id>?d AND NAME LIKE ?', 3, 'a%');

Для «распаковки» параметров и получения конечного SQL-выражения используйте `Db::prepareQuery('QUERY', param1, param2, ...)`. Выполнение `prepareQuery` для предыдущего запроса вернёт строку:

    SELECT * FROM users WHERE id>3 AND NAME 'a%'

Первый параметр, благодаря уточнению `?d` (digit) был выведен без кавычек, а значение явно приведено к числовому типу.

###2. Объект SQL-условий
При компонентном подходе часто бывает необходимо представить условие в SQL запросе в виде объекта. Изменяя <i>Объект условий</i> в существующем компоненте, можно легко влиять на данные внутри него, не изменяя код самого компонента.

Класс `DbCond` имеет ряд методов для реализации различных вариаций SQL-фильтрации. Метод `DbCond::all()` преобразует все условия обратно в SQL-строку для подстановки её в конечный запрос.

Рассмотрим несколько примеров использования <i>Объекта условий</i>:

    (new DbCond)->addF('id', 3)->all();
    // вернёт `WHERE 1 AND id = 3`

    (new DbCond)->addFromFilter('id', 3)->all();
    // вернёт `WHERE 1 AND id > 3`

    (new DbCond)->addRangeFilter('id', 3, 5)->all();
    // вернёт `WHERE 1 AND id > 3 AND id < 5`

Пример с полным запросом:

    $cond = new DbCond('info');
    $cond->addRangeFilter('age', 17, 60, null, true);
    $goodWorkers = db()->select(
      'SELET users.* FROM users LEFT JOIN info ON info.userId=user.id'. //
      $cond->all()
    );

Конечный запрос:

    SQL:
    SELECT users.* FROM users
    LEFT JOIN info ON info.userId=user.id
    WHERE 1 AND info.age > "17" AND info.age < '60';

Следующие методы добавляют в _Объект условий_ фильтры:

  {apiPhp DbCond}


###3. db-модели

Класс `DbModelCore` предоставляет интерфейс для работы с db-моделями.

__db-модель__ - это объект класса `DbModel` (или его предка), созданный на основе данных одной строки таблицы базы данных.

При работе с db-моделями существует 4 основных процедуры: создание, измненение, получение, удаление:

{apiPhp DbModelCore}

###Экспорт в sql-dump

    // Выводит все таблицы в базе
    print (new DbDumper)->getDump();
    
    // Одна таблица
    $dumper = new DbDumper;
    print $dumper->getDump('table');

    // Только определённые записи в таблице
    $dumper = new DbDumper;
    $dumper->cond->addF('id', [1, 5, 8]);
    print $dumper->getDump('table');
    
    // Только записи определённого пользователя, без комментариев в шапке
    $dumper = new DbDumper(null, ['noHeaders' => true]);
    $dumper->cond->addF('userId', 5);
    print $dumper->getDump('table');

##Система динамических данных (dd-система)

__Система динамических данных (dd)__ — это система по управлению таблицами и записями базы данных.
Она имеет богатый встроенный функционал, позволяющий создавать источники данных с готовыми компонентами (Client-Side + Server-Side) для их управления.
Такие базовые компоненты так же ускоряют реализацию своих систем управления, CRM, адмиок и т.п. с помощью наследования и переопределения их частей.

_Dd-система_ имеет веб-интерфейс для управления. Он обеспечивает управление _dd-структурами_, _dd-полями_, _dd-тегами_ и _dd-записями_.
Это не значит, что вы не можете использовать в своём проекте генерацию dd-сущностей через API. Но для наших целей этого не требуется.
Рассмотрим пример, в котором использование _dd-системы_ будет крайне актуально.

Пусть у нас имеется база пользователей. Каждый пользователь имеет профиль с личной информацией, 
а так же свои фотографии. Нам необходимо позволить редактировать всё это только этому пользователю
и администратору сайта.

В БД такая структура выглядела бы, как один-к-одному для информации профиля и один-ко-многим
для фотографий. В dd-системе всё будет так же, только в разы проще.

Создадим через _Панель управления_ 2 структуры: «профиль» и «фотографии». Пользователи
находятся в системной таблице `users`. Она уже существует.

В структуру «профиль» добавим следующие поля:

<table>
<tr>
  <td>Ф.И.О.</td>
  <td>text</td>
</tr>
<tr>
  <td>Пара слов о себе</td>
  <td>wisiwigSimple</td>
</tr>
<tr>
  <td>Секретный вопрос</td>
  <td>text</td>
</tr>
</table>

В структуру «фотографии» добавим:

<table>
<tr>
  <td>Изображение</td>
  <td>image</td>
</tr>
<tr>
  <td>Описание</td>
  <td>description</td>
</tr>
</table>

Теперь настроим контроллер для работы с ними:

    class CtrlProfile extends CtrlBase {
      function action_show() {
        $this->d['someVar'] = (new Ddo('profile', 'siteItem'))->els();
      }
      function action_edit() {
        $manager = new DdItemsManager('profile');
        if ($manager->getItem($this->req['id'])['userId'] != Auth::get('id'))
          throw new AccessDenied;
        if ($manager->requestUpdate($this->req['id'])) {
          $this->redirect('show');
        } else {
          $this->d['someVar'] = $manager->form->html();
        }
      }
    }

    class CtrlPhotos extends CtrlBase {
      function action_new() {
        $manager = new DdItemsManager('photos');
        if ($manager->requestCreate()) {
          $this->d['someVar'] = 'Фото добавлено';
        } else {
          $this->d['someVar'] = $manager->form->html();
        }
      }
    }

В листинге присутствует 2 новых класса: `Ddo` и `DdItemsManager`.

`DdItemsManager` — это _Менеджер данных_ _dd-системы_.

`Ddo` (Dynamic Data Output) — класс для автоматического HTML-рендеринга для dd-записей.

####dd-cтруктура
__dd-структура__ — это MySQL-таблица хранящая запии структуры.
Её имя начинается с префикса `dd_i_`.
Таблица имеет ряд системных полей: `id`, `oid`, `active`, `dateCreate`, `dateUpdate`, `ip`, `userId`.

Параметры _dd-структуры_ сохраняются в таблице `dd_structures`.

#####API для работы со структурами
{apiPhp DdStructureCore}

^^Управление _dd-структурами_ в _Панели управления_: `/admin/ddStructure`

####[dd-поля](./ngn.ddFields)

####dd-запись
Это строка в таблице структуры и привязаные к ней dd-теги

^^Управление _dd-записями_ в _Панели управления_: `/admin/ddItems/имя_структуры`.

####dd-тег
__dd-тег__ — это своеобразный маркер, которым наделяется dd-запись.

Одно из свойств _dd-тега_ - это мультивыбор. Оно определяет можно ли добавлять для _dd-записи_ больше одного тега.

Ещё одно свойство - древовидность. Оно позволяет связывать теги между собой в иерархические структуры. Таким образом при назначении dd-записи корневого маркера, ей будут назначены и все дочерние, связанные с ним.

_dd-теги_ создаются в _Панели управления_, но есть так же и свойство, разрешающее создание тегов «по требованию», если они присутствуют в dd-записи.

^^Управление _dd-тегами_ в _Панели управления_: `/admin/ddField/имя_структуры`. Ссылка на редактирование появится около _Тегового поля_. Его нужно создать

_Теговое поле_ - поле dd-формы реализующее _Элемент поля формы_ и _Экшены поля_ для работы с _dd-тегами_.

_dd-форма_ - не представляет собой ничего интересного

####ddo
__ddo__ (Dynamic Data Output) — это библиотека типизрованого HTML-рендеринга dd-записей.
С помощью неё значения dd-полей могу рендериться сами.
Благодаря такому подходу рендеринг списка записей из dd-структуры,
сколько бы полей она не содержала, займёт всего несколько символов кода.
Так же бывает полезно определить стиль вывода некой dd-структуры и укомпоновать
этот стиль в качестве наследуемого от Ddo класса. Такой класс можно подключать
в разлных разделах одного проекта, отличающихся друг от друга логикой или
вообще в разных проектах, сохраняя базовую логику вывода и расширяя её по необходимости
с помощью ООП наследования.



Ddo поддерживает целый ряд способов определения шаблонов.

#####Способы настройки шаблонов

- ddddItemsBegin
- ddddItemsEnd
- ddddByName
- ddddByType

#####Ddo API

  {apiPhp Ddo}

ddo-элемент — это значение одной записи, преобразованное в HTML-элемент

####dd-фильтр для контроллера
__dd-фильтр для контроллера__ — это функционал позволяющий внедрить в любой контроллер логику для получения
и фильтрации записей через строку запроса браузера.

####dd-crud для контроллера
__dd-crud для контроллера__ — это функционал позволяющий внедрить в любой контроллер логику для реализации
операция создания, получения, изменения и удаления dd-записей.

Добавьте в кашему контроллеру трейт `DdParamFilterCtrl`. Реализуйте его абстрактный метод `DdParamFilterCtrl::paramFilterItems()` и используйте его для получения записей в контроллере.
Для них будут автоматически работать следующие фильтры адресной строки:

- `/controller/path/d.1;12;1989-7;6;2014` -- период по дате
- `/controller/path/d.7;6;2014 -- определенный` день
- `/controller/path/d.6;2014` -- месяц
- `/controller/path/d.2014` -- год
- `/controller/path/t.tag-name` -- по имени тега
- `/controller/path/t2.123` -- по ID тега
- `/controller/path/u.8` -- по ID юзера
- `/controller/path/v.someValue` -- по значению поля в dd-таблице

Пример контроллера, выводящего записи из dd-структуры по фильтру:

    class CtrlProducts extends CtrlBase {
    use DdCrudCtrl;
    
      function action_default() {
        $ddo = new Ddo($this->getStrName(), 'siteItems');
        $ddo->setItems($this->_items()->getItems());
        $this->d['html'] = $ddo->els();
      }
    
    }
    
####экспорт в mysql dump

    // выгрузает все записи
    DdCore::export('structureName', $condition);
    
    // выгружает записи с 1 по 100 ID
    $condition = new DbCond;
    $condition->addRangeFilter('id', 1, 100);
    DdCore::export('structureName', $condition);

##Очереди
###Как включить воркер
Создать файл конфигурации `config/vars/queue.php` в любом базовом каталоге:

    <?php
    
    return [
      'workers' => 3 // количество воркеров
    ];

Выполнить команду утилиты <a href="/doc/pm">pm</a>

    pm localProject updateIndex {projectName}
    pm localProject daemons {projectName}

###Как выключить воркер
Добавить в массив в файле `config/vars/queue.php` флаг `disable`

    <?php
    
    return [
      'workers' => 3, // количество воркеров
      'disable => true
    ];

И выполнить команду утилиты <a href="/doc/pm">pm</a>

    pm localProject daemons {projectName}

###Добавление заданий в очередь
{apiPhp Queue}

##Как добавить собственную конфигурацию для проекта

    project/site/config/struct/vars.php

##[CliAccess](/doc/cliAccess)
##[SFLM](/doc/sflm)
##[Создание документации и формат NgnMarkdown](/doc/ngnMarkdown)
