#Static File Library Manager#
Автозагрузчик JavaScript объектов

<!--
Предпосылки создания автозагрузчика JS-файлов с необходимыми объектами/классами вылились из концепции
fullstack-фреймворка, где существуют компоненты не только на стороне сервера, но и клиент-серверные компоненты,
представляющие сотобой набор из контроллера, моделей базы данных, конфигурации, классов сервероной бизнес логики,
а так же клиентской части: визуальное отображение (рендеринг HTML), та же бизнес-логика и классы, компоненты фреймворка,
необходимые для реализации всего этого. Создавая диалог или поле формы, которое требует JS-логики. Каждый раз
мы нуждаемся в автозагрузке базовых объектов. Как Вы бы вели себя при классическом подходе? Подключили бы
`<script src=".../someJQueryComponent.js"></script>`. И остались бы счастиливы. Но в больших приложения
компоненты не являются нечтом монолитным. Они состоят из множества саб-классов и саб-объектов. В Ngn для того, что
бы создать диалог с формой, нужно подключить файл Ngn.Dialog.RequestForm. Но будем ли мы знать о том, что нам нужно это сделать,
если поле формы использует класс `Ngn.Dialog.Abc` наследуемый от `Ngn.Dialog.RequestForm`. Конечно да. И мы подключим этот
`Ngn.Dialog.RequestForm` и `Ngn.Dialog.Abc`, а потом сольём их в один файл. Как же быть, когда мы новый элемент 
формы создаётся через web-интерфейс контент-менеджеров? Элемент формы, который использует совершенно уникальный для,
него JS-код который не нужен был до этого момента. Конечно. Ответ один. Весь JS-код для всех типов полей должен
быть подключён всегда. Но как быть, если в нашем фреймворке сотня типов полей? И эта сотня типов использует ещё
около сотни базовых объектов-хелперов, объединяющих функции вроде работы со строками и т.п. Подключать все имеющиеся
в фреймворке JS-объекты не кажется правельным. А отслеживать все эти связи вручную - не лёгкая и адски-рутинная задача.
На помощь приходит Sflm. Он сем отследит связи, подключит только нужное в нужном порядке.
-->

##Какие паттерны парсятся в коде##
Кажде слово с большой буквы

 - Ngn.Asd
 - Ngn.Asd.Asd
 - Ngn.Asd.Asd.Asd

##Как происходит поиск файлов по Валидным Именам##

regexp: [A-Z]*.js

##Немного логов##

Посмотрите на лог вызовов библиотеки, что бы примерно понять как работает автозагрузчик.

Первый пример - пустой вызов. Подключаются базовые библиотеки.
{console run "Sflm::\$output = true; Sflm::setFrontendName('a'); Sflm::clearCache(); Sflm::frontend('js')->store();"}

В следующем примере происходит добавление всего одного класса `Ngn.Picker.Date`. Посмотрите какие необходимые библиотеки подключаются в результате:
{console run "Sflm::\$output = true; Sflm::setFrontendName('a'); Sflm::clearCache(); Sflm::frontend('js')->addClass('Ngn.Picker.Date'); Sflm::frontend('js')->store();"}

##Архитектура##
Sflm работает в контексте _sflm-фронтенда_. sflm-фронтенд - это своеобразное хранилище объектов,
которое инкрементально пополняется каждый раз, когда происходит добавление нового объекта.
sflm-фронтенд определяется до создания контроллера. Контроллер - это то место, где начинается
бизнес-логика, а значит и подключения JS-объектов. Так что точкой определения sflm-фронтенда является
роутер. Это то место где вы ещё в силах выбрать sflm-фронтенд.

    // метод Роутера
    protected function init() {
      Sflm::setFrontendName('frontendName');
    }

Далее выполняется вся бизнес-логика от экшенов контроллера до php-кода находящегося в шаблонах. Добавление
JS-объектов может происходить где угодно, но должно закончиться до выполнения метода `SflmFrontendJs::store()`.
Он вызывается в `CtrlBase::getOutput()` уже после вывода.

##Кэширование##

^Используйте константу BUILD_MODE что бы включить режим runtime-сборки в базовом контроллере `CtrlBase`.

Кэширование происходит на уровне sflm-фронтенда.
Сохранение путей фронтенда осуществляется методом `SflmFrontend::storePaths()`.

Стандартное поведение базового контрллера `CtrlBase` вызывает сохранение путей
при генерации вывода `CtrlBase::getOutput()`.

Это означает, что до этого момента в любых местах кода может быть использован
метод `SflmFrontend::_addPath($path)` для добавления в кэш sflm-фронтенда новых путей.
`SflmFrontend::storePaths()` выполняет сохранение только если добавленный путь ещё не был в кэше.

##Добавление JS-объектов##
Основным и самым удобным методом для добавления объектов является `SflmFrontendJs::addClass()`. Он автоматически ищет
объект или класс во всех каталогах со статическими файлами `Sflm::$absBasePaths`. Для стандартного проекта
это будут каталоги `WEBROOT_PATH.'/m'` и `NGN_PATH.'/u'`. Объектами/классами в Sflm являются файлы формата
`Ngn.asd.Abc`/`Ngn.Asd.Abc`/`Ngn.Asd.dsa.Abc`/ и т.п. Последний кусок (часть имени файла без расширения разбитая точками)
должна начинаться с большой буквы. Объект должен обязательно находиться в неймспейсе `Ngn`. Это обусловлено
использованием в системе других JS-компонентов, подключаемых статически, не отвечающих конвенциям, необходимым
для правильной работы Sflm.

    Sflm::frontend('js')->addClass('Ngn.Name');

##Определения##

###sflm-путь###
sflm-uri - это относительный URI по которому CSS/JS файл можно получить через HTTP. URI указывается относительно базового домена проекта и не должен начинаться со слэша.

###sflm-файл###
sflm-файл - это абсолютный путь к CSS/JS файлу

###sflm-ресурс###
sflm-ресурсом может быть:

- sflm-uri
- sflm-файл

###sflm-библиотека###
sflm-библиотека - это список sflm-путей или других sflm-библиотек.
sflm-библиотека представляет собой `Config Var` находящуюся в подпапке `sfl`.
Т.е. для создания библиотеки с именем "example" нужно создать файл
в одном из базовых ngn-кталогов по пути "config/vars/sfl/example.php" с содержанием:

    <?php

    return [
      'i/js/ngn/Ngn.SomeClass.js'
    ];

###sflm-фронтенд###
sflm-фронтенда - это пространство, хранящее в себе уникальный список
sflm-ресурсов. Оно определяется обычным именем из латинских символов.
Например для всех контроллеров, унаследованных от `CtrlDefault` будет определён
sflm-фронтенд с именем "default". А для всех контроллеров админки `CtrlAdmin` - 
sflm-фронтенд "admin".

По имени sflm-фроентенда задаётся так же название sflm-библиотеки, которая будет всегда
подключатся в первую очереь для него.

##API###
{apiPhp SflmFrontend}


##Подключение зависимостей из JS-файлов##

    // @requiresBefore s2/js/common/tpl?name=fontSelect&controller=/font/ajax_browse
    // @requiresBefore i/some/path, Ngn.Some.Class
    // @requiresAfter i/js/ngn/comeLib.js
    
^ Важно использовать однострочные `//` комментарии

##Отладка отдельных файлов##

При работе с JS-библиотекми, собранными через Sflm важно сохранить быстроту разработки и отладки, но при этом не
потерять фишки по автоматическому отслеживанию связей. Ведь одни обеспечивают надёжность сборки компонентов и
уберегают от лишней рутины. Sflm имеет встроенный механизм отладки отдельных файлов на локальном сервере.
При этом важно иметь их первоначальную версию на удаленном dev-сервере, что бы сработало подключение необходимых
в файле компоненотов, средствами Sflm. Что бы начать отладку отдельных файлов используйте следующие статисеские свойства,
переопределим их в `init.php` файле проекта.

Настройки для отладки одного файла с именем `Ngn.Dialog.js`: 

    Sflm::$debugUrl = 'http://localhost:8888';
    Sflm::$debugPaths = [
      'js' => [
        'Ngn.Dialog.js'
      ]
    ];
    
Или так для всей папки:
    
    Sflm::$debugPaths = [
      'js' => [
        'i/ngn/dialog/'
      ]
    ];

^ После добавления путей в Sflm::$debugPaths, необходимо <a href="/doc/ngn.md#Очистка_кэша">очистить кэш приложения</a>

##Пути sflm-фронтенда##
Текущий список путей sflm-фронтенда можно посмотреть через командную строку. Для этого
существует cli-утилита `sflm`.

{console sflm csdemo}
{console sflm csdemo paths default css}
{console sflm csdemo paths default js}

##Сборка##

    pm localProject cmd projectName "(new SflmBuild)->run()"


<!--
##FAQ##
###JS-объект не найден. Что делать?###

Вы видите в браузере ошибку JavaScritp'а:

    Uncaught TypeError: Ngn.SomeClass is not a constructor
    
Т.е. файл с этим классом подключен не был. Что делать в таких ситуациях?
    
Скорее всего файл с этим классом был подключен через тег <script> минуя `Sflm`.
Используйте `Sflm::fromntend('js')->addClass('/path/with/class.js');`
-->